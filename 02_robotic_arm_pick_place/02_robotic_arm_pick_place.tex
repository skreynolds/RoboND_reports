\documentclass[a4paper]{article}

%--------------------------------------------------------------------------
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{float}
\usepackage{inconsolata}
\usepackage{listings}
\usepackage{pstricks-add}
\usepackage{siunitx}
\usepackage[most]{tcolorbox}
\usepackage{tikz}
\usepackage{xfrac}
\usepackage{hyperref}

\usetikzlibrary{shapes.geometric,angles}

\newcommand\w[1]{\makebox[3.4em]{$#1$}}
\DeclareMathOperator{\atantwo}{atan2}
%------------------------------------------------------------
\graphicspath{{./fig/}}

%------------------------------------------------------------
\setlength{\parindent}{0in}

\lstdefinestyle{Python}{
	language        = Python,
	basicstyle      = \ttfamily,
	keywordstyle    = \color{blue},
	keywordstyle    = [2] \color{teal}, % just to check that it works
	stringstyle     = \color{green},
	commentstyle    = \color{red}\ttfamily
}

%------------------------------------------------------------

\newtcblisting[auto counter]{sexylisting}[2][]{sharp corners, 
    fonttitle=\bfseries, colframe=gray, listing only, 
    listing options={basicstyle=\ttfamily,language=Python}, 
    title=Listing \thetcbcounter: #2, #1}

%--------------------------------------------------------------------------
\begin{document}
\title{Udacity: Robotic Arm Pick \& Place Report}
\author{Shane Reynolds}
\maketitle

\tableofcontents

\newpage

%--------------------------------------------------------------------------
\section{Introduction \& Background}
The Amazon Pick and Place Robotics Challenge is a competition designed to help increase collaboration between the industrial and robotics research communities. Amazon has successfully implemented a number of robotic systems which largely eliminate the need for activities like searching and walking in their fulfilment centres, however, one of the main challenges that Amazon is yet to solve is picking and stowing objects reliably in an unstructured environment. To successfully achieve this objective, there are a number of tasks that need to be successfully completed. These include:
\begin{enumerate}
\item Identification of the target object in the unstructured environment;
\item Manipulator path planning to the object;
\item Successful execution of a reach and grasp manoeuvre; and
\item Physical relocation of the grasped object to the desired location.
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{image1}
\caption{Kuka KR210 anthropomorphic industrial robot with 6 degrees of freedom}
\end{figure}

Path planning and execution of the desired manoeuvre is largely a solved problem. The move execution is dependent on inverse kinematics. The inverse kinematics (IK) of a robot is the mathematical conversion of position in Cartesian space to the joint angles which allows the robot end effector to reach the desired position. The end effector position in space can be thought of in 2 separate domains: Cartesian world coordinates, or Joint Angle space. Typically, analytical work is done in Cartesian space - three dimensional space is the native environment that humans live in and is easier to conceptualise. Robots, however, position themselves by making adjustments to electrical or hydraulic actuators - these actuators receive instructions based on Joint Angle. This project explores the IK derivation, and implementation, for the Kuka KR210. The KR210 is a 6 degree of freedom (dof) anthropomorphic robotic arm shown in Figure 1. The project culminates with the implementation of an IK server, which is a ROS service receiving a series of points in Cartesian space (world coordinate frame), and returning a vector of Joint Angles after applying the IK transform. The implementation will be undertaken in ROS, which utilises simulation engines Rviz and Gazebo. Figures 2 and 3 show the Kuka KR210 in simulation.

\begin{figure}[h]
\centering
\begin{minipage}[t]{0.45\linewidth}
\centering
\frame{\includegraphics[height=4cm]{kuka_gazebo}}
\caption{A picture of the KR210 in Gazebo}
\end{minipage}
\hspace{1cm}
\begin{minipage}[t]{0.45\linewidth}
\centering
\frame{\includegraphics[height=4cm]{kuka_rviz}}
\caption{A picture of the KR210 in Rviz}
\end{minipage}
\end{figure}

\newpage

%--------------------------------------------------------------------------
\section{Methods \& Implementation}

\subsection{Determining the Denavit-Hartenburg Parameters}
Forward and Inverse kinematic analysis relies heavily on successful specification of transformation matrices between the physical elements of the robot, which we call links. In order to determine these transformation matrices, we need to assign coordinate frames to the robot links. Doing this in an arbitrary fashion will often result in the determination of 6 parameters for each transformation matrix, which makes this process undesirably complex. Denavit and Hartenburg (1955) determined an algorithmic approach to the assignment of coordinate frames to the robot's links which reduces the number of parameters needed to describe each transformation matrix to 4. Assuming that $\hat{x}_i$, $\hat{y}_i$, and $\hat{z}_i$ are the $x$, $y$, and $z$ axes respectively for coordinate frame $i$, then these parameters are defined in Table 1.

\begin{table}[h]
\centering
\caption{Description of the Denavit-Hartenburg parameters}
\begin{tabular}{cp{8cm}}
\toprule
\textbf{Parameter} & \textbf{Description}\\
\midrule
$\alpha_{i-1}$ & Twist angle, and is determined by the angle between the $\hat{z}_{i-1}$ and $\hat{z}_i$, measured about the $\hat{x}_{i-1}$ axis\\
 & \\
$a_{i-1}$ & Distance from $\hat{z}_{i-1}$ to $\hat{z}_i$ measured along $\hat{x}_{i-1}$, where $\hat{x}_{i-1}$ is orthogonal to $\hat{z}_{i-1}$, and $\hat{x}_{i-1}$ is orthogonal to $\hat{z}_i$\\
 & \\
$d_i$ & Signed distance between $\hat{x}_i$ and $\hat{x}_{i-1}$, measured along $\hat{z}_i$\\
 & \\
$\theta_i$ & Angle between $\hat{x_{i-1}}$ and $\hat{x}_i$, measured about $\hat{z}_i$\\
\bottomrule
\end{tabular}
\end{table}

The KR210 has a base link, 6 degrees of freedom, and an end effector. Each of the links require a coordinate frame assignment, making a total requirement of 8 coordinate frames. Each of the joints were systematically labelled from 1 to 6, starting with the joint closest to the \verb|base_link|. Following this, each of the links were assigned a number from 0 to 7. It must be noted that link 0 is actually the \verb|base_link|, and link 7 is the \verb|end_effector|. For the sake of simplicity, the \verb|base_link| and \verb|end_effector| will retain their names throughout this report. Coordinate frames were assigned to the links according to the DH procedure. Each link can be thought of as being associated with a joint. The \verb|base_link| is associated with the fixed ground, link 1 is associated with joint 1, and so on. To assign the coordinate frame to a link, DH requires the $\hat{z}_i$ coordinate axis for link $i$ to pass through the joint $i$ axis of rotation. To start the DH convention of coordinate frame assignment, the \verb|base| frame is assigned arbitrarily. Each $\hat{x}_i$ axis, for coordinate frame $i$, is determined using $\hat{z}_i$, and $\hat{z}_{1+1}$. The $\hat{x}_i$ axes are assigned dependent on whether the $\hat{z}_i$, and $\hat{z}_{i+1}$ axes are:
\begin{enumerate}
\item \textbf{Skewed:} if the $\hat{z}_i$ and $\hat{z}_{i+1}$ axes are skewed, then the $\hat{x}_i$ axis is assigned along the normal from $\hat{z}_i$ to $\hat{z}_{i+1}$.
\item \textbf{Intersecting:} if the $\hat{z}_i$ and $\hat{z}_{i+1}$ axes intersect, then the $\hat{x}_i$ axis is assigned in an arbitrary position such that it is normal to the plane formed by $\hat{z}_i$ and $\hat{z}_{i+1}$
\item \textbf{Coincident:} if the $\hat{z}_i$ and $\hat{z}_{i+1}$ axes are parallel or coincident, then the $\hat{x}_i$ axis assignment is arbitrary along the $\hat{z}_i axis$
\end{enumerate}

To reiterate, the $\hat{x}_i$ axis is assigned dependent on the geometric orientation of the $\hat{z}_i$, and $\hat{z}_{i+1}$ axes. The $\hat{y}_i$ axis is assigned to complete the right handed coordinate frame assignment. The full DH coordinate frame assignment for the KR210 can be seen in Figure 4.

\begin{figure}[h]
\centering
\scalebox{0.8}{\input{./arm_sketch/kinematics.tex}}
\caption{Sexy robot drawing}
\end{figure}

The DH parameters, which are used to specify the transformations from one coordinate frame to another, are determined once the coordinate frames have been assigned. The full DH parameter specification can be seen in Table 2. It must be noted that the values for $d_i$ and $a_{i-1}$ were found using the unified robot description format (urdf) file, which contains the model specifications for Gazebo. The partial urdf file can be seen in Appendix A, which shows the joint angle information. The dimensions taken from the urdf file are marked up on Figure 4, with one notable exception: $a_3$. The DH parameter for $a_3$ is the orthogonal distance between $\hat{y}_3$ and $\hat{y}_4$, and is -0.054$\si{\meter}$. This was omitted from the diagram to avoid cluttering the picture. The DH parameter specifications are used in conjunction with equation (1) to specify the transformation matrices from coordinate frame $i-1$ to coordinate frame $i$. This is further explored in Section 2.2.\\

\begin{equation}
	^{i-1} T_i =
	\begin{bmatrix}
	\cos \theta_i 							& -\sin \theta_i  							& 0 					& a_{i-1}\\
	\sin \theta_i \cdot \cos \alpha_{i-1}	& \cos \theta_i \cdot \cos \alpha_{i-1}		& -\sin \alpha_{i-1} 	& -d_i \cdot \sin \alpha_{i-1}\\
	\sin \theta_i \cdot \sin \alpha_{i-1}	& \cos \theta_i \cdot \sin \alpha_{i-1}		& \cos \alpha_{i-1}		& d_i \cdot \cos \alpha_{i-1}\\
	0										& 0											& 0						& 1
	\end{bmatrix}
\end{equation}

\vspace{0.25cm}

\begin{minipage}{0.45\textwidth}
One final note of importance is the calculation of the angle between the axis $\hat{y}_3$ and the line formed by $J_3$ and $J_5$. Whilst it is not immediately clear why we need this value, it will be important for Section 2.3.1 when analysing the robot geometries. We note that the horizontal distance along $\hat{y}_3$, between $J_3$ and $J_5$, is 1.5$\si{\meter}$.
\end{minipage}
\hspace{1cm}
\begin{minipage}{0.45\textwidth}
	\centering
	\captionof{table}{DH parameter table}
	\begin{tabular}{ccccc}
		\toprule
		$^{i-1} T_i$ 				& $d_i$ 	& $\theta_i$ 					& $\alpha_{i-1}$ 	& $a_{i-1}$\\ 
		\midrule
		$^\texttt{base} T_1$ 		& 0.750 	& $\theta_1$ 					& 0 				& 0.000\\
		$^1 T_2$ 					& 0.000 	& $\theta_2 - \frac{\pi}{2}$ 	& $-\sfrac{\pi}{2}$ & 0.350\\
		$^2 T_3$ 					& 0.000 	& $\theta_3$ 					& 0 				& 1.250\\
		$^3 T_4$ 					& 1.500 	& $\theta_4$ 					& $-\sfrac{\pi}{2}$ & -0.054\\
		$^4 T_5$ 					& 0.000 	& $\theta_5$ 					& $\sfrac{\pi}{2}$ 	& 0.000\\
		$^5 T_6$ 					& 0.000 	& $\theta_6$ 					& $-\sfrac{\pi}{2}$ & 0.000\\
		$^6 T_\texttt{end\_eff}$ 	& 0.303 	& 0 							& 0 				& 0.000\\
		\bottomrule
	\end{tabular}
\end{minipage}

\vspace{0.5cm}

The vertical distance, along $\hat{x}_3$, is 0.054$\si{\meter}$. Hence it follows that:
\begin{align*}
\tan \beta 	&= \frac{0.054}{1.5}\\
\beta 		&= \arctan \frac{0.054}{1.5}\\
\beta		&= 2.06^o
\end{align*}  

This angle of 2.06$^o$ has been added to the 90$^o$ formed by $\hat{x}_3$ and $\hat{y}_3$, and has been included in Figure 9.

\newpage

\subsection{Forward Kinematics}
The forward kinematics problem is concerned with taking the agular positions of the individual joints and finding the position of the robot's end effector in three dimensional Cartesian space. This section of the report is broken down into three subsections:
\begin{enumerate}
	\item Derivation of the transformation matrices, $^{i-1} T_i$
	\item Derivation of transformation correction matrix 
	\item Verification of transformation matrices
\end{enumerate}

\subsubsection{Derivation of the transformation matrices}
Using the DH parameters derived in Section 2.1, in addition to equation (1), we can derive a series of matrices, $^{i-1} T_i$, which describe the transformation of a vector in one coordinate frame $i$, to that of another coordinate frame $i-1$.\\

The individual transformation matrices are shown below:\\
\small
\begin{minipage}[t]{0.45\textwidth}
	\begin{align*}
	^\texttt{base} T_1 &=
	\begin{bmatrix}
	\cos \theta_1 	& -\sin \theta_1 	& 0 	& 0\\
	\sin \theta_1	& \cos \theta_1		& 0		& 0\\
	0				& 0					& 1		& 0.75\\
	\w0				& \w0				& \w0	& \w1\\
	\end{bmatrix}\\
	^2 T_3 &=
	\begin{bmatrix}
	\cos \theta_3 	& -\sin \theta_3 	& 0 	& 1.25\\
	\sin \theta_3	& \cos \theta_3		& 0		& 0\\
	0				& 0					& 1		& 0\\
	\w0				& \w0				& \w0	& \w1
	\end{bmatrix}\\
	^4 T_5 &=
	\begin{bmatrix}
	\cos \theta_5	& -\sin \theta_5	& 0		& 0\\
	0				& 0					& -1	& 0\\
	\sin \theta_5	& \cos \theta_5		& 0		& 0\\
	\w0				& \w0				& \w0	& \w1
	\end{bmatrix}\\
	^6 T_\texttt{end\_eff} &=
	\begin{bmatrix}
	1				& 0					& 0		& 0\\
	0				& 1					& 0		& 0\\
	0				& 0					& \w1		& 0.303\\
	\w0				& \w0				& 0		& \w1
	\end{bmatrix}
	\end{align*}
\end{minipage}
\hspace{0.2cm}
\begin{minipage}[t]{0.45\textwidth}
	\begin{align*}
	^1 T_2 &=
	\begin{bmatrix}
	\sin \theta_2	& \cos \theta_2 	& 0		& 0.35\\
	0				& 0					& 1		& 0\\
	\cos \theta_2	& -\sin \theta_2	& 0		& 0\\
	\w0				& \w0				& \w0	& \w1	
	\end{bmatrix}\\
	^3 T_4 &=
	\begin{bmatrix}
	\cos \theta_4	& -\sin \theta_4	& 0		& -0.054\\
	0				& 0					& 1		& 1.5\\
	-\sin \theta_4 	& -\cos \theta_4	& 0		& 0\\
	\w0				& \w0				& \w0	& \w1 
	\end{bmatrix}\\
	^5 T_6 &=
	\begin{bmatrix}
	\cos \theta_6	& -\sin \theta_6	& 0		& 0\\
	0				& 0					& 1		& 0\\
	-\sin \theta_6	& -\cos \theta_6	& 0		& 0\\
	\w0				& \w0				& \w0	& \w1
	\end{bmatrix}
	\end{align*}
\end{minipage}

\vspace{0.5cm}
\normalsize
The full transformation from the \verb|base_link| to the \verb|end_effector| is determined by matrix multiplication, shown in equation.
\begin{align}
	^{\texttt{base\_link}} T_{\texttt{end\_effector}} &= ^{\texttt{base\_link}} T_{1} \cdot ^{1} T_{2} \cdot ^{2} T_{3} \cdot ^{3} T_{4} \cdot ^{4} T_{5} \cdot ^{5} T_{6} \cdot ^{6} T_{\texttt{end\_effector}}
\end{align}

For the sake of brevity, the full specification for equation (2), which is $^\texttt{base\_link} T_\texttt{end\_effector}$, has not been shown - showing this transformation matrix without evaluating $\theta_i$ would take several paragraphs.

\subsubsection{Correction of Transformation Matrices}
The orientation of the DH base frame, shown in Figure 3, has been selected so that it aligns with the world simulation frame (defined in the urdf file). It must be noted, however, that the final DH frame for the gripper does not have the same orientation as the urdf file since the DH algorithm was employed to assign the frames. This has ramifications for any forward kinematic analysis we perform using transformation matrices defined with DH parameters. The difference in frame orientation can be better understood by comparing Figures 5 and 6.

\begin{figure}[h]
	\centering
	\begin{minipage}[t]{0.45\textwidth}
		\centering
		\begin{tikzpicture}
		\draw[thick,->] (0,0,0) -- (1.5,0,0) node[anchor = north]{$z$};
		\draw[thick,->] (0,0,0) -- (0,1.5,0) node[anchor = east]{$x$};
		\draw[thick,->] (0,0,0) -- (0,0,2) node[anchor = north]{$y$};
		\end{tikzpicture}
		\caption{The orientation of the DH frame with respect to the world frame which is located at the base of the robot, shown in Figure 6}
	\end{minipage}
	\hspace{1cm}
	\begin{minipage}[t]{0.45\textwidth}
		\centering
		\begin{tikzpicture}
		\draw[thick,->] (0,0,0) -- (1.8,0,0) node[anchor = north]{$x$};
		\draw[thick,->] (0,0,0) -- (0,1.8,0) node[anchor = east]{$z$};
		\draw[thick,->] (0,0,0) -- (0,0,-2) node[anchor = west]{$y$};
		\end{tikzpicture}
		\caption{The orientation of thhe world coordinate frame.}
	\end{minipage}
\end{figure}
 \newpage
To provide a correction to the transformation matrix, $^\texttt{base} T_{\texttt{end\_eff}}$, two steps need to be taken:
\begin{enumerate}
	\item A rotation about the $z$-axis by $\pi$: $R_z(\pi)$; and
	\item A rotation about the $y$-axis by $-\sfrac{\pi}{2}$: $R_y(-\sfrac{\pi}{2})$
\end{enumerate}

The correction matrix, $R_{correction}$, is defined mathematically as follows:
\begin{align}
R_{correction} 	&= R_z(\pi) R_y(-\sfrac{\pi}{2})				
\end{align}

Evaluating equation (3) allows the static implementation of this correction matrix, which saves on computational resources required to run the IK server. The implemented resultant correction can be seen in Listing 1, and the matrix is as follows:
\begin{align}
R_{correction} = \begin{bmatrix}-1 & 0 & 0\\0 & -1 & 0\\0 & 0 & 1\end{bmatrix} \begin{bmatrix}0 & 0 & -1\\0 & 1 & 0\\1 & 0 & 0\end{bmatrix} = \begin{bmatrix}0 & 0 & 1\\0 & -1 & 0\\1 & 0 & 0\end{bmatrix}
\end{align}

\subsubsection{Verification of Transformation Matrices}
To provide some assurance that the Python implementation is correct, analysis was undertaken using a script called \verb|forwardKinematics.py|, which can be found in Appendix B. The ROS launch script, \verb|forward_kinematics.launch|, provides a simulation of the robot in which the joint angles could be manually adjusted, and the position and orientation of the robot's frames observed. This is shown in Figure 5.

\begin{figure}[h]
	\centering
	\frame{\includegraphics[scale=0.15]{rviz_fk_debug}}
	\caption{The Gazebo simulation of the robot using ROS, which allows the user to input joint angles, and get pose information as output. This was used to confirm that the the DH frames had been correctly assigned, and that the DH parameters were correctly determined resulting in accurate transformation matrices.}
\end{figure}

Rviz reports the postion of the gripper frame as a position vector, however, the gripper orientation is reported in Quarternions, which have to be converted to a rotation matrix in order to compare this to the calculated results from \verb|forwardKinematics.py|. The Python script \verb|forwardKinematics.py| contains four test cases with varying angles $\theta_i$, such that $i \in \{1,2,3,4,5,6\}$. These test cases can be seen in Table 3.

\begin{table}[h]
	\centering
	\caption{Test cases for the joint angles, which were entered into the ROS similation to observe the end effector position and orientation.}
	\begin{tabular}{ccccccc}
		\toprule
		\textbf{Test Case} & $\theta_1$ & $\theta_2$ & $\theta_3$ & $\theta_4$ & $\theta_5$ & $\theta_6$\\
		\midrule
		Case 1 & 0 & 0 & 0 & 0 & 0 & 0\\
		Case 2 & -0.65 & 0.45 & -0.37 & 0.96 & 0.78 & 0.46\\
		Case 3 & -0.79 & -0.11 & -2.34 & 1.96 & 1.14 & -3.69\\
		Case 4 & -2.99 & -0.12 & 0.94 & 4.06 & 1.29 & -4.15\\
		\bottomrule
	\end{tabular}
\end{table}

Each case was entered into the simulation, and the position vector was recorded, along with the orientation Quaternion. The recorded Qaternion was converted to a rotation matrix from which roll, pitch, and yaw can be read from the main diagonal of the matrix. The results of this process can be seen in Table 4.

\begin{table}[h]
	\centering
	\caption{Position vector, Quaternion, and rotation matrix observered from the manual simulation of the KR210.}
	\small
	\begin{tabular}{clll}
		\toprule
		\textbf{Case} & \textbf{Position Vector} & \textbf{Quaternion} & \textbf{Rotation Matrix}\\
		\midrule
		 & & & \\
		1 & $\begin{bmatrix}2.153 & 0.000 & 1.946\end{bmatrix}$ & $\begin{bmatrix}0 & 0 & 0 & 1\end{bmatrix}$ & $\begin{bmatrix}1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1\end{bmatrix}$\\
		 & & & \\
		2 & $\begin{bmatrix}2.167 & -1.429 & 1.560\end{bmatrix}$ & $\begin{bmatrix}0.698 & 0.183 & -0.153 & 0.674\end{bmatrix}$ & $\begin{bmatrix}0.886 & 0.462 & 0.033 \\ 0.049 & -0.022 & -0.998 \\ -0.461 & 0.886 & -0.043\end{bmatrix}$\\
		 & & & \\
		3 & $\begin{bmatrix}-0.566 & 0.940 & 2.993\end{bmatrix}$ & $\begin{bmatrix}0.612 & 0.488 & 0.388 & 0.485\end{bmatrix}$ & $\begin{bmatrix}0.221 & 0.221 & 0.949 \\ 0.975 & -0.051 & -0.215 \\ 0.001 & 0.973 & -0.227\end{bmatrix}$\\
		 & & & \\
		4 & $\begin{bmatrix}-1.393 & 0.017 & 0.915\end{bmatrix}$ & $\begin{bmatrix}0.013 & -0.229 & 0.901 & 0.368\end{bmatrix}$ & $\begin{bmatrix}-0.728 & -0.669 & -0.145 \\ 0.657 & -0.623 & -0.423 \\ 0.192 & -0.403 & 0.895\end{bmatrix}$\\
		 & & & \\
		\bottomrule
	\end{tabular}
\end{table}

Running the \verb|forwardKinematics.py| script outputs the numerical, corrected transformation matrix, $^{\texttt{i-1}} T_{\texttt{i}}$, for each of the four test cases. The results can be seen in Table 5. Comparing the simulation results shown in Table 4 with the calcuated results from the transformation matrix, shown in Table 5, we see that position vecotrs and rotation matrices are almost identical for all four test cases. There are some small variations, however, this can be, in part, attributed to numerical truncation when performing calculations. 

\begin{table}[h]
	\centering
	\caption{Calculated position vector and orientation matrix using the matrix transfrom from the end effector to the base link.}
	\small
	\begin{tabular}{cll}
		\toprule
		\textbf{Case} & \textbf{Position Vector} & \textbf{Rotation Matrix}\\
		\midrule
		& & \\
		1 & $\begin{bmatrix}2.153 & 0 & 1.946\end{bmatrix}$ & $\begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{bmatrix}$\\
		& & \\
		2 & $\begin{bmatrix}2.167 & -1.428 & 1.562\end{bmatrix}$ & $\begin{bmatrix}0.887 & 0.460 & 0.030\\0.049 & -0.029 & -0.998\\-0.458 & 0.887 & -0.049\end{bmatrix}$\\
		& & \\
		3 & $\begin{bmatrix}-0.573 & 0.941 & 2.99\end{bmatrix}$ & $\begin{bmatrix}0.216 & 0.221 & 0.951\\0.976 & -0.049 & -0.210\\0.001 & 0.974 & -0.227\end{bmatrix}$\\
		& & \\
		4 & $\begin{bmatrix}-1.389 & 0.022 & 0.916\end{bmatrix}$ & $\begin{bmatrix}-0.723 & -0.674 & -0.145\\0.662 & -0.619 & -0.423\\0.195 & 0.402 & 0.894\end{bmatrix}$\\
		& & \\
		\bottomrule
	\end{tabular}
\end{table}

\newpage

\subsection{Inverse Kinematics}
Inverse kinematics (IK) is the process of determining the joint angles for each degrees of freedom in a robotic system, given the position of the robot's end effector in Cartesian space. The Kuka KR210 has 6 degrees of freedom, and hence, there are 6 joint angles which need to be determined. The anthropomorphic arm design allows us to exploit the geometry in the final 3 joints of the system. It is the intersection of the axes of rotation that is the important geometrical characteristic. This configuration of the final three joints is refered to as a spherecal wrist. This allow kinematic decoupling of the first three joints from the last three joints, providing the facility to find a closed form solution to the problem. The closed form solution is presented below, in two parts: first three joint angles, and final three joint angles

\subsubsection{First Three Joint Angles ($\theta_1$, $\theta_2$, and $\theta_3$)}
Consider the first three joints in a pose shown in Figure 8. The point $(\omega_x, \omega_y, \omega_z)$ represents the location of the spherical wrist. Using this information, the first joint angle, $\theta_1$, can be found using basic trigonometry:
\begin{align}
\theta_1 = \atantwo \bigg( \frac{\omega_y}{\omega_x} \bigg)
\end{align}

To determine expressions for $\theta_2$ and $\theta_3$, we focus our attention on joints 2 and 3, as shown in Figure 9. We note that this Figure uses the existing $z$-axis, however, to help with the analysis a new axis is established: $(xy)'$. This is done since joints $J_2$ and $J_3$ operate in the same 2D plane, which simplifies the analysis. This allows the re-expression of the spherical wrist coordinates as $(r,s)$, where:
\begin{align}
r &= \sqrt{\omega_x^2 + \omega_y^2} - 0.35\\
s &= \omega_z - 0.75 
\end{align}

\begin{minipage}{0.45\textwidth}
	Considering the triangle formed by the vertices at $J_2$, $J_3$, and $W$, we can find an experssion for $\eta$, as follows:
	\begin{align}
	180^o &= \eta + 92.06^o + \theta_3 \nonumber\\
	\eta &= 87.94^o - \theta_3 \nonumber\\
	\eta &= 1.5348 \si{\radian} - \theta_3
	\end{align}
	
	Employing the cosine rule on the triangle formed by vertices $J_2$, $J_3$, and $W$, we note that:
	\begin{align*}
	L^2 = k_1^2 + k_2^2 - 2 \cdot k_1 \cdot k_2 \cdot \cos \eta
	\end{align*}
	
	Rearranging this expression we get the following expression for $\cos \eta$:
	\begin{align}
	\cos \eta = \frac{k_1^2 + k_2^2 - L^2}{2 \cdot k_1 \cdot k_2} := D
	\end{align}
\end{minipage}
\hspace{1cm}
\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}
		% Axes
		\draw[thick,->] (0,0,0) -- (6,0,0) node[anchor = north]{$x$};
		\draw[thick,->] (0,0,0) -- (0,6,0) node[anchor = east]{$z$};
		\draw[thick,->] (0,0,0) -- (0,0,-10) node[anchor = west]{$y$};
		
		% Robot Frame
		\draw[line width=2pt,purple] (0,0,0) -- (0,1.5,0);
		\draw[line width=2pt,purple] (0,1.5,0) -- (1,1.5,-1);
		\draw[line width=2pt,purple] (1,1.5,-1) -- (2,3,-2);
		\draw[line width=2pt,purple] (2,3,-2) -- (3,1,-3);
		
		% Guidelines
		\draw[->,dashed, blue] (0,0,0) -- (3.5,0,-3.5) node[anchor=west]{$(xy)'$};
		\draw[dashed, blue] (1,1.5,-1) -- (1,0,-1);
		\draw[dashed, blue] (2,3,-2) -- (2,0,-2);
		\draw[dashed, blue] (3,1,-3) -- (3,0,-3);
		\draw[dashed, blue] (3,0,-3) -- (3,0,0);
		
		% Dh frames
		\draw[line width=1.5pt, green, ->] (0,0,0) -- (2.5,0,0) node[anchor = north]{$\hat{x}_\texttt{base}$};
		\draw[line width=1.5pt, green, ->] (2,3,-2) -- (2,5,-2) node[anchor = east]{$\hat{x}_1$ rotated by $\frac{\pi}{2}$};
		\draw[line width=1.5pt, green, ->] (2,3,-2) -- (3,4.5,-3) node[anchor = south]{$\hat{x}_2$};
		\draw[line width=1.5pt, green, ->] (2,3,-2) -- (3.3,4,-3.3) node[anchor = south]{$\hat{x}_3$};
		
		% Labelling Angles
		\draw[<->] (2,0,0)  arc (0:31:1cm);
		\node [black] at (1.7,0.2) {$\theta_1$};
		
		% Joints
		\node [black, label=left:{$J_1$}] at (0,0.75,0) {\textbullet};
		\node [black, label=above:{$J_2$}] at (1,1.5,-1) {\textbullet};
		\node [black, label=left:{$J_3$}] at (2,3,-2) {\textbullet};
		\node [black, label=right:{$W(\omega_x,\omega_y,\omega_z)$}] at (3,1,-3) {\textbullet};
		
		% Putting in wrist coordinate/Joint Labelling
		\end{tikzpicture}
		\captionof{figure}{Robot geometry showing the first three joints, and the spherical wrist in 3D space.}
\end{minipage}
\vspace{1cm}
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	% Axes
	\draw[thick, ->] (0,0) -- (8,0) node[anchor=north] {$(xy)'$};
	\draw[thick, ->] (0,0) -- (0,7) node[anchor=east] {$z$};
	
	% Robot
	\draw[line width=2pt, purple] (0,0) -- (3,4.5);
	\draw[line width=2pt, purple] (3,4.5) -- (4.5,2);
	
	% Completing triangle
	\draw[line width=2pt, orange] (0,0) -- (4.5,2);
	
	% Dh Axes
	\draw[line width=1.5pt, green, ->] (3,4.5) -- (4.5,6.75) node[anchor=south] {$\hat{x}_2$};
	\draw[line width=1.5pt, green, ->] (3,4.5) -- (5.3,5.9) node[anchor=south] {$\hat{x}_3$};
	\draw[line width=1.5pt, green, ->] (0,0) -- (6,0) node[anchor=south] {$\hat{x}_1$};
	
	% Joints
	\node [black, label=left:{$J_2$}] at (0,0) {\textbullet};
	\node [black, label=left:{$J_3$}] at (3,4.5) {\textbullet};
	\node [black, label=right:{$W(r, s)$}] at (4.5,2) {\textbullet};
	
	% Guidance lines
	\draw[dashed, blue] (4.5,2) -- (4.5,0);
	
	% Drawing Arcs
	\draw[<->] (1,0) arc (0:22:1);
	\draw[<->] (0.927,0.375) arc (22:54:1);
	\draw[<->] (2,0) arc (0:55:2);
	\draw[<->] (1.14,1.638) arc (55:90:2);
	\draw[<->] [domain=32:55] plot ({cos(\x)+3}, {sin(\x)+4.5});
	\draw[<->] [domain=-57:32] plot ({cos(\x)+3}, {sin(\x)+4.5});
	\draw[<->] [domain=-122:-60] plot ({cos(\x)+3}, {sin(\x)+4.5});
	
	% Labelling Arcs
	\node [black] at (1.2,0.25) {$\alpha$};
	\node [black] at (0.95,0.8) {$\xi$};
	\node [black] at (2.6,0.45) {$\frac{\pi}{2} - \theta_2$};
	\node [black] at (0.7,2.3) {$\theta_2$};
	\node [black] at (4,5.5) {$\theta_3$};
	\node [black] at (4.7,4.3) {92.06$^o$};
	\node [black] at (3,3.8) {$\eta$};
	\node [black] at (1.5,3) {$k_1$};
	\node [black] at (4.3,3) {$k_2$};
	\node [black] at (2.8,1.5) {$L$};
	\end{tikzpicture}
	\caption{Roboto goemetry focusing on joints 2 and 3, which operate in the same plane allowing for analysis in 2D.}
\end{figure}



Equation (9), along with Pythagoras' theorem, allows us to determine an expression for $\sin \eta$:
\begin{align}
\sin \eta = \sqrt{1 - D^2}
\end{align}

Using equations (9) and (10), we get:
\begin{align}
\tan \eta &= \frac{\sin \eta}{\cos \eta} = \frac{\sqrt{1 - D^2}}{D} \nonumber\\
\eta &= \atantwo \bigg(\frac{\sqrt{1-D^2}}{D}\bigg)
\end{align}

Substituting equation (11) into equation (8), we arrive at an expression for $\theta_3$:
\begin{align}
\theta_3 = 1.5348\si{\radian} - \atantwo \bigg(\frac{\sqrt{1 - D^2}}{D}\bigg)
\end{align}

Again, considering the triangle formed by the vertices $J_2$, $J_3$, and $W$, we can use the cosine rule to get the following expression:
\begin{align*}
k_2^2 = k_1^2 + L^2 - 2 \cdot k_1 \cdot L \cdot \cos \xi
\end{align*}

Rearranging the above equation we find an expression for $\cos \xi$:
\begin{align}
\cos \xi = \frac{k_1^2 + L^2 - k_2^2}{2 \cdot k_1 \cdot L} := K
\end{align}

Equation (13), along with Pythagoras' theorem, allows us to determine an expression for $\sin \xi$:
\begin{align}
\sin \xi = \sqrt{1 - K^2}
\end{align}

Using equations (13) and (14), we get:
\begin{align}
\tan \xi &= \frac{\sin \xi}{\cos \xi} = \frac{\sqrt{1 - K^2}}{K} \nonumber\\
\xi &= \atantwo \bigg(\frac{\sqrt{1-K^2}}{K}\bigg)
\end{align}

Now, considering the right angled triangle formed between the line connecting points $J_2$ and $W$, we can find and expression for $\alpha$:
\begin{align}
\alpha = \atantwo \bigg(\frac{s}{r}\bigg)
\end{align}

Finally, we note that the angle between assigned DH coordinate axes $\hat{x}_1$ and $\hat{x}_2$ is $\sfrac{\pi}{2} - \theta_2$, and hence we get the following expression:
\begin{align}
\frac{\pi}{2} - \theta_2 &= \alpha + \xi \nonumber\\
\theta_2 &= \frac{\pi}{2} - \alpha - \xi
\end{align}

Substituing equations (15) and (16) into equation (17), we arrive at an expression for $\theta_2$:
\begin{align}
\theta_2 = \frac{\pi}{2} - \atantwo \bigg(\frac{s}{r}\bigg) - \atantwo \bigg(\frac{\sqrt{1 - K^2}}{K}\bigg)
\end{align}

\subsubsection{Final Three Joint Angles ($\theta_4$, $\theta_5$, and $\theta_6$)}
To find the final three joint angles, $\theta_4$, $\theta_5$, and $\theta_6$ we expolit the following relationship between the FK rotation matrix $^\texttt{base} R_6$, and the desired orientation of the end gripper, $R_{rpy}$, which is given in an IK problem. We note that:
\begin{align}
^\texttt{base} R_6 = R_{rpy}
\end{align}

It is important to note that the orientation of the robotic frame at joint 6 will be the same as the \verb|end_effector| orientation, since the \verb|end_effector| is simply a translation from joint 6 , with no rotation. From our FK analysis, we have the ability to break up the rotation matrix, in equation (15), as follows:
\begin{align}
^\texttt{base} R_6 = {}^{\texttt{base}}R_3 \cdot {}^{3}R_6 = R_{rpy}
\end{align}

Hence, rearranging equation (16), we get:
\begin{align*}
^3 R_6 = \big({}^{\texttt{base}}R_3\big)^{-1} \cdot R_{rpy}
\end{align*}

Since any rotation matrix is orthogonal, we can write:
\begin{align}
^3 R_6 = \big({}^{\texttt{base}}R_3\big)^{T} \cdot R_{rpy}
\end{align}

Now, using \verb|SymPy| it is easy to obtain an expression for $^3 R_6$. For the sake of brevity, and ease of reading, $\cos \theta_i$ will be expressed as $c_i$, and $\sin \theta_i$ will similarly be expressed as $s_i$. The expression is as follows:
\begin{align}
^3 R_6 =
\begin{bmatrix}
c_4 \cdot c_5 \cdot c_6 - s_4 \cdot s_6 & -s_4 \cdot c_6 - s_6 \cdot c_4 \cdot c_5 & -s_5 \cdot c_4\\
s_5 \cdot c_6 & -s_5 \cdot s_6 & c_5\\
-s_4 \cdot c_5 \cdot c_6 - s_6 \cdot c_4 & s_4 \cdot s_6 \cdot c_5 - c_4 \cdot c_6 & s_4 \cdot s_5
\end{bmatrix}
\end{align}

The rotation matrix $\big({}^{\texttt{base}}R_3\big)^{T}$ could be expressed in a similar way, but at this stage of solving the problem we have explicit expressions for $\theta_1$, $\theta_2$, and $\theta_3$. Evaluating these expressions allows the calculation of a numerical matrix expression for $\big({}^{\texttt{base}}R_3\big)^{T}$. Further to this, since the desired orientation of the end effector is specificed at the beginning of an IK problem, we can use the given $\theta_{roll}$, $\theta_{pitch}$, and $\theta_{yaw}$ to evaluate the matrix $R_{rpy}$. Hence, the resultant matrix from the multiplicaiton of $\big({}^{\texttt{base}}R_3\big)^{T}$ and $R_{rpy}$ is numerical. We express the resultant matrix elements with $r_{ij}$, and assume the following:
\begin{align}
\big({}^{\texttt{base}}R_3\big)^{T} \cdot R_{rpy} =
\begin{bmatrix}
r_{11} & r_{12} & r_{13}\\
r_{21} & r_{22} & r_{23}\\
r_{31} & r_{32} & r_{33}
\end{bmatrix}
\end{align}

Using matrix equality with equation (22) and (23), we note that:
\begin{align}
c_5 = r_{23}
\end{align}

Which we can also write as:
\begin{align}
s_5 = \sqrt{1 - r_{23}^2}
\end{align}

Hence, using equations (24) and (25) we solve for $\theta_5$ as follows:
\begin{align}
\theta_5 = \atantwo \bigg(\frac{\sqrt{1 - r_{23}^2}}{r_{23}}\bigg)
\end{align}

We can use a similar approach to solve for both $\theta_4$ and $\theta_6$. Using matrix equality with equation (22) and (23), we get that:
\begin{align}
s_5 \cdot c_6 &= r_{21}\\ -s_5 \cdot s_6 &= r_{22}
\end{align}

Hence, dividing (28) by (27), we get that:
\begin{align}
\theta_6 = \atantwo \bigg(-\frac{r_{22}}{r_{21}}\bigg)
\end{align}

Finally, we get that:
\begin{align}
-s_5 \cdot c_4 &= r_{13}\\
s_4 \cdot s_5 &= r_{33}
\end{align}

Hence, dividing equation (31) by (30) we solve for the final joint angles:
\begin{align}
\theta_4 = \atantwo \bigg(-\frac{r_{33}}{r_{13}}\bigg)
\end{align}

\subsubsection{Implementation of IK Server}
The main objective of this paper is to implement the \verb|IK_server.py|. This server waits to recieve a list of required poses, with each pose consisting of a Cartesian position in 3D space, along with roll, pitch and yaw orientation angles for the end effector. The full \verb|IK_server.py| implementation can be found in Appendix C. This section of the report will explain each step of the implementation, providing code snippets to aid understanding. The main body of the \verb|IK_server.py| is contained in the callback function \verb|handle_calculate_IK|. Once a list of poses is received, \verb|handle_calculate_IK| is called, and transformation matrix $^\texttt{base} T_3$, is evaluated and stored in the variable \verb|T0_3|. This process includes defining symbols for the DH parameters, and assigning them values - determined in Section 2.1. Further, the rotation correction matrix, found in Section 2.2.2, is specified, and the rotation matrix $^\texttt{base} R_3$ is extracted from the $^\texttt{base} T_3$ transformation. The code snippet showing these steps can be found in Listing 1. 

\begin{figure}[h]\footnotesize
	\begin{sexylisting}{Initialsation of variables and specification of transformation matrices}
### Your FK code here
# Create symbols
q1, q2, q3, q4, q5, q6, q7 = symbols('q1:8')
d1, d2, d3, d4, d5, d6, d7 = symbols('d1:8')
a0, a1, a2, a3, a4, a5, a6 = symbols('a0:7')
alpha0, alpha1, alpha2, alpha3, alpha4, alpha5, alpha6 = symbols('alpha0:7')

# Create Modified DH parameters
s = {alpha0:     0,    a0:      0,    d1: 0.75,
     alpha1: -pi/2,    a1:   0.35,    d2:    0,    q2: (q2 - pi/2),
     alpha2:     0,    a2:   1.25,    d3:    0}

# Define Modified DH Transformation matrix
T0_1 = transMat(q1, alpha0, d1, a0)
T1_2 = transMat(q2, alpha1, d2, a1)
T2_3 = transMat(q3, alpha2, d3, a2)

T0_1 = T0_1.subs(s)
T1_2 = T1_2.subs(s)
T2_3 = T2_3.subs(s)

# Create individual transformation matrices
T0_2 = T0_1*T1_2
T0_3 = T0_2*T2_3

# Specify the intrinsic rotation matrix for correcting from DH to urdf
R_corr = Matrix([[0,  0, 1],
[0, -1, 0],
[1,  0, 0]])

# Extract rotation matrices from the transformation matrices
R0_3 = T0_3[0:3,0:3]	
	\end{sexylisting}
\end{figure}

The transformation matrices are built using the function \verb|transMat(q, alpha, d, a)|, which takes the DH parameters specified earlier as arguements. The \verb|transMat| function can be seen in Listing 2.

\begin{figure}[h]\footnotesize
	\begin{sexylisting}{The function used to build transformation matrices}
def transMat(q, alpha, d, a):
   T = Matrix([[           cos(q),           -sin(q),           0,             a],
               [sin(q)*cos(alpha), cos(q)*cos(alpha), -sin(alpha), -sin(alpha)*d],
               [sin(q)*sin(alpha), cos(q)*sin(alpha),  cos(alpha),  cos(alpha)*d],
               [                 0,                0,           0,             1]])
   return T	
	\end{sexylisting}
\end{figure}

The next part of the code extracts the position in three dimensional Cartesian space and stores the values in the variables \verb|px|, \verb|py|, and \verb|pz|. Similarly, the orientation is stored in the variables \verb|roll|, \verb|pitch|, and \verb|yaw|. Using these 6 variables, position of the spherical wrist is determined and stored in \verb|wx|, \verb|wy|, and \verb|wz|. This is shown in Listing 3

\begin{figure}[h]\footnotesize
	\begin{sexylisting}{Position/orientation is extracted and used to calculate spherical wrist position}
# Extract end-effector position and orientation from request
# px,py,pz = end-effector position
# roll, pitch, yaw = end-effector orientation
px = req.poses[x].position.x
py = req.poses[x].position.y
pz = req.poses[x].position.z

(roll, pitch, yaw) = tf.transformations.euler_from_quaternion(
[req.poses[x].orientation.x, req.poses[x].orientation.y,
req.poses[x].orientation.z, req.poses[x].orientation.w])
# Define Modified DH Transformation matrix

### Your IK code here
# Compensate for rotation discrepancy between DH parameters and Gazebo
Rrpy = R_z(yaw) * R_y(pitch) * R_x(roll) * R_corr
#
# Calculate spherical wrist position
wx = px - (0.303) * Rrpy[0,2] # x-coord of wrist position
wy = py - (0.303) * Rrpy[1,2] # y-coord of wrist position
wz = pz - (0.303) * Rrpy[2,2] # z-coord of wrist position
	\end{sexylisting}
\end{figure}

Finally, the callback function calculates the joint angles. To do this, the code first establishes variables $\texttt{r}$, $\texttt{ss}$, $\texttt{k1}$, $\texttt{k2}$, $\texttt{D}$, and $\texttt{K}$, which were calculated based on the robot's geometry - outlined in Section 2.3.1. The first three joint angles $\theta_1$, $\theta_2$, and $\theta_3$ are calculated using implementations of equations (5), (18), and (12) respectively. The numerical evaluation of $\big({}^{\texttt{base}}R_3 \big)^T \cdot R_{rpy}$ is based on recently determined values of $\theta_1$, $\theta_2$, and $\theta_3$, and the desired roll, pitch, and yaw orientation angles. Finally, $\theta_4$, $\theta_5$, and $\theta_6$ are determined using an implementation of equations (32), (26), and (29) respectively. Listing 4 shows the implementation of this code. The call back function calculates and returns the required joint angles for each of the desired poses in the input list.

\begin{figure}[h]\footnotesize
	\begin{sexylisting}{Code snippet showing the evaluation of the joint angles for a given position and orientation}
r = sqrt(wx**2 + wy**2) - 0.35 #implemented okay
ss = wz - 0.75 #implemented okay

k1 = 1.25 #implemented okay
k2 = 1.5 #implemented okay

D = (k1**2 + k2**2 - (r**2 + ss**2))/(2 * k1 * k2) #implemented okay
K = (k1**2 + (r**2 + ss**2) - k2**2)/(2*sqrt(r**2 + ss**2)*k1) #implemented okay

# First three joint variables
theta1 = atan2(wy,wx).evalf()
theta2 = (pi/2 - atan2(ss,r) - atan2(sqrt(1 - K**2), K)).evalf()
theta3 = 1.53484 - atan2(sqrt(1 - D**2), D).evalf()

R36rpy = (R0_3.transpose() * Rrpy).evalf(subs={q1: theta1, q2: theta2, q3: theta3})

# Second three joint variables
theta4 = atan2(R36rpy[2,2], -R36rpy[0,2]).evalf()
theta5 = atan2(sqrt(1 - R36rpy[1,2]**2), R36rpy[1,2]).evalf()
theta6 = atan2(-R36rpy[1,1], R36rpy[1,0]).evalf()
	\end{sexylisting}
\end{figure}

\newpage

%------------------------------------------------------------
\section{Results \& Conclusion}
The FK verification of the transformation matrices revealed some small numerical errors, however, implementation of the \verb|IK_server.py| worked as intended. The pick and place operation can be seen in Figures 10 and 11. A full video of the Kuka KR210 pick and place operation can be seen on the YouTube link provided below. Note the simulation execution is slow and you may like to watch this at 2 $\times$ speed.

\begin{center}
	\url{https://youtu.be/F2vZQHOaYb8}
\end{center}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[scale=0.1]{pick}
		\caption{Kuka KR210 completing a pick trajectory.}
	\end{minipage}
	\hspace{1cm}
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[scale=0.1]{place}
		\caption{Kuka KR210 completing a place trajectory.}
	\end{minipage}
\end{figure}

\newpage

%------------------------------------------------------------
\section{Further Enhancements}
Since the joint angles are bound to $-\pi$ and $\pi$, this can lead to a complication in the arm movements when traversing from one reference point to another. The complication arises when the robot needs to make a small adjustment beyond $-\pi$ or $\pi$ when it is at either of these boundries. The resulting movement sees the robot execute a full joint revolution, which can appear awkward, especially for the wrist joints. A simple example of this phenomena would be if the robot needed to move a joint to -182$^o$. Instead of performing this movement, the robot would instead send the joint to +178$^o$ causing a full joint revolution.\\

Another bug that can be observed in the continuous mode of robot motion is that execution doesn't allow the robot enough time to actually grip the object, resulting in the object being left on the shelf in some instances. The final two improvements that could be undertaken are adding an error tracking visualisation, and speeding up the simulation, though these are not essential.
%------------------------------------------------------------
\section{References}
 Denavit, J., Hartenberg, R. (1955). "A kinematic notation for lower-pair mechanisms based on matrices". Trans ASME J. Appl. Mech. 23: 215–221.
\newpage
%------------------------------------------------------------
\section{Appendix A}
A section of the KR210 urdf which lists the incremental information of the joint locations with respect to the base. This information was used to determine the DH parameter values of $d_i$ and $a_{i-1}$.
\lstset{
	frame=single,
	basicstyle=\ttfamily,
	numbers=left,
	showstringspaces=false,
}

\tiny
\lstinputlisting{./code/kr210.urdf.xacro}

\newpage

%------------------------------------------------------------
\section{Appendix B}
\normalsize The code used to help verify that the DH coordinate frames had been applied correctly, and the DH parameters correctly determined. The script calculates the transformation matrices, and the final end effector pose, which can be compared with actual results from a simulator to ensure that the FK calculations match.
\tiny
\lstinputlisting[style=Python]{./code/forwardKinematics.py}

\newpage

%------------------------------------------------------------
\section{Appendix C}
\normalsize The final inverse kinematics server implementation.
\tiny
\lstinputlisting[style=Python]{./code/IK_server.py}
\end{document}